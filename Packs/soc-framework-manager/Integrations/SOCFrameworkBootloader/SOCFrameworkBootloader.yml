commonfields:
  id: SOCFrameworkBootloader
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: SOCFrameworkBootloader
display: SOCFrameworkBootloader
category: Utilities
image: data:image/png;base64,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
imagepath: xsoar-files://xsoar/images/SOCFrameworkBootloader_9fa64812-26fa-40a0-8c66-9723a69e5bf5.png
description: |-
  Resolves SOC Framework pack install manifests by reading pack_catalog.json and each pack's xsoar_config.json.
    Designed for public GitHub today and proxy/token delivery later.
detaileddescription: |-
  ### Community Contributed Integration
   #### Integration Author: Cortex
   No support or maintenance is provided by the author. Customers are encouraged to engage with the user community for questions and guidance at the [Cortex XSOAR Live Discussions](https://live.paloaltonetworks.com/t5/cortex-xsoar-discussions/bd-p/Cortex_XSOAR_Discussions).
  ***
  ## Hello World
  - This section explains how to configure the instance of HelloWorld in Cortex:
  - You can use the following API Key: `dummy-key`


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/hello-world)
sectionorder:
- Connect
- Collect
configuration:
- supportedModules: []
  display: Catalog URL
  name: catalog_url
  defaultvalue: https://raw.githubusercontent.com/Palo-Cortex/secops-framework/refs/heads/main/pack_catalog.json
  type: 12
  required: true
- supportedModules: []
  display: Auth Token (optional)
  name: auth_token
  type: 4
  required: false
- supportedModules: []
  display: Auth Header Name (optional)
  name: auth_header_name
  defaultvalue: Authorization
  type: 0
  required: false
- supportedModules: []
  display: Use Bearer Prefix
  name: use_bearer
  defaultvalue: "true"
  type: 8
  required: false
- supportedModules: []
  display: Timeout (seconds)
  name: timeout
  type: 0
  required: false
- supportedModules: []
  display: Trust any certificate (insecure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- supportedModules: []
  display: Use system proxy settings
  name: proxy
  defaultvalue: "false"
  type: 8
  required: false
script:
  commands:
  - supportedModules: []
    name: socfw-get-catalog
    arguments:
    - supportedModules: []
      name: catalog_url
      description: Override the integration instance catalog_url for this call.
    outputs:
    - contextPath: SOCFW.Catalog
      description: The full catalog JSON.
      type: unknown
    description: Fetch the pack_catalog.json from the configured catalog_url.
  - supportedModules: []
    name: socfw-get-install-manifest
    arguments:
    - supportedModules: []
      name: pack_id
      required: true
      description: Pack ID from pack_catalog.json (e.g. soc-optimization-unified).
    - supportedModules: []
      name: include_hidden
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Allow resolving packs with visible=false.
      defaultValue: "False"
    - supportedModules: []
      name: catalog_url
      description: Override the integration instance catalog_url for this call.
    outputs:
    - contextPath: SOCFW.Manifest
      description: 'Resolved install manifest (custom_packs, marketplace_packs, integration_instances).           type:
        Unknown'
    description: Resolve a pack id to its xsoar_config.json and return the install
      manifest.
  script: |
    import requests


    def _arg_to_bool(val, default=False):
        if val is None:
            return default
        if isinstance(val, bool):
            return val
        s = str(val).strip().lower()
        return s in ("true", "1", "yes", "y", "on")


    def _params():
        try:
            return demisto.params()
        except Exception:
            return {}


    def _args():
        try:
            return demisto.args()
        except Exception:
            return {}


    def _runtime_http_settings():
        p = _params()
        timeout_raw = p.get("timeout", "30")
        try:
            timeout = int(timeout_raw)
        except Exception:
            timeout = 30

        insecure = _arg_to_bool(p.get("insecure", False), False)
        verify = not insecure

        use_proxy = _arg_to_bool(p.get("proxy", False), False)
        return timeout, verify, use_proxy


    def _http_get_json(url):
        timeout, verify, use_proxy = _runtime_http_settings()

        session = requests.Session()
        if not use_proxy:
            session.trust_env = False  # don't inherit proxy env vars

        try:
            resp = session.get(url, timeout=timeout, verify=verify)
            resp.raise_for_status()
        except requests.exceptions.RequestException as e:
            raise Exception(f"HTTP GET failed for {url}: {e}")

        try:
            data = resp.json()
        except Exception as e:
            raise Exception(f"Response from {url} is not valid JSON: {e}")

        if not isinstance(data, dict):
            raise Exception(f"Expected JSON object from {url}, got {type(data)}")

        return data


    def _catalog_url(args_dict):
        p = _params()
        return (args_dict.get("catalog_url") or p.get("catalog_url") or "").strip()


    def _result(contents, entry_context=None, readable=None):
        entry = {
            "Type": 1,  # note
            "ContentsFormat": "json",
            "Contents": contents,
        }
        if entry_context is not None:
            entry["EntryContext"] = entry_context
        if readable is not None:
            entry["HumanReadable"] = readable
            entry["ContentsFormat"] = "json"
        demisto.results(entry)


    def _error(msg):
        demisto.results({"Type": 4, "Contents": str(msg)})


    def cmd_get_catalog():
        args_dict = _args()
        url = _catalog_url(args_dict)
        if not url:
            raise Exception("catalog_url is not configured on the instance (or passed as an argument).")

        catalog = _http_get_json(url)
        packs = catalog.get("packs", [])

        if not isinstance(packs, list):
            raise Exception("Catalog JSON does not contain a valid 'packs' list.")

        rows = []
        for p in packs:
            if not isinstance(p, dict):
                continue
            rows.append({
                "id": p.get("id"),
                "display_name": p.get("display_name"),
                "version": p.get("version"),
                "visible": p.get("visible"),
                "path": p.get("path"),
            })

        readable = "### SOC Framework Pack Catalog\n"
        if rows:
            readable += tableToMarkdown(
                "Available Packs",
                rows,
                headers=["id", "display_name", "version", "visible", "path"]
            )
        else:
            readable += "_No packs found in catalog._"

        _result(
            contents=catalog,
            entry_context={"SOCFW": {"Catalog": catalog, "CatalogPacks": rows}},
            readable=readable,
        )


    def _find_pack(catalog, pack_id):
        packs = catalog.get("packs", [])
        if not isinstance(packs, list):
            raise Exception("Catalog JSON does not contain a valid 'packs' list.")
        for p in packs:
            if isinstance(p, dict) and p.get("id") == pack_id:
                return p
        raise Exception(f"Pack not found in catalog: {pack_id}")


    def cmd_get_install_manifest():
        args_dict = _args()

        pack_id = (args_dict.get("pack_id") or "").strip()
        if not pack_id:
            raise Exception("pack_id argument is required.")

        include_hidden = _arg_to_bool(args_dict.get("include_hidden", "true"), True)

        url = _catalog_url(args_dict)
        if not url:
            raise Exception("catalog_url is not configured on the instance (or passed as an argument).")

        catalog = _http_get_json(url)
        pack = _find_pack(catalog, pack_id)

        visible = bool(pack.get("visible", True))
        if not include_hidden and not visible:
            raise Exception(f"Pack '{pack_id}' is visible=false and include_hidden=false.")

        xsoar_config_url = (pack.get("xsoar_config") or "").strip()
        if not xsoar_config_url:
            raise Exception(f"Pack '{pack_id}' does not include xsoar_config URL.")

        xsoar_config = _http_get_json(xsoar_config_url)

        manifest = {
            "pack_id": pack.get("id"),
            "display_name": pack.get("display_name"),
            "pack_version": pack.get("version"),
            "visible": visible,
            "path": pack.get("path"),
            "xsoar_config_url": xsoar_config_url,
            "custom_packs": xsoar_config.get("custom_packs", []),
            "marketplace_packs": xsoar_config.get("marketplace_packs", []),
            "integration_instances": xsoar_config.get("integration_instances", []),
        }

        # Provide a human readable hint: list the custom pack urls
        cp = manifest.get("custom_packs") or []
        urls = []
        if isinstance(cp, list):
            for item in cp:
                if isinstance(item, dict) and item.get("url"):
                    urls.append(item.get("url"))

        readable = "Resolved install manifest.\n"
        if urls:
            readable += "Custom pack ZIP URLs:\n- " + "\n- ".join(urls[:10])
            if len(urls) > 10:
                readable += f"\n... and {len(urls) - 10} more"
        else:
            readable += "No custom_packs[].url entries found."

        _result(
            contents=manifest,
            entry_context={"SOCFW": {"Manifest": manifest}},
            readable=readable,
        )


    def test_module():
        p = _params()
        url = (p.get("catalog_url") or "").strip()
        if not url:
            raise Exception("catalog_url is not configured on the instance.")
        catalog = _http_get_json(url)
        packs = catalog.get("packs")
        if not isinstance(packs, list):
            raise Exception("Catalog fetched but does not include a valid 'packs' list.")
        return "ok"


    def main():
        try:
            command = demisto.command()
            if command == "test-module":
                demisto.results(test_module())
            elif command == "socfw-get-catalog":
                cmd_get_catalog()
            elif command == "socfw-get-install-manifest":
                cmd_get_install_manifest()
            else:
                raise Exception(f"Unsupported command: {command}")
        except Exception as e:
            _error(e)


    if __name__ in ("__main__", "builtins"):
        main()
  type: python
  dockerimage: demisto/python3:3.12.8.3296088
  subtype: python3
  runonce: false
signature: ""
restrictioncenter: {}
