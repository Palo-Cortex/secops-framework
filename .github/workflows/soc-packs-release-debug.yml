name: SOC Packs Release DEBUG

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  PACKS_DIR: Packs

jobs:
  debug-release-packs:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install demisto-sdk
        run: |
          python -m pip install --upgrade pip
          pip install "demisto-sdk>=1.0.0"

      # 1) Discover packs
      - name: Discover packs
        id: discover
        run: |
          python - << 'PY'
          import os
          from pathlib import Path

          packs_dir = Path(os.environ["PACKS_DIR"])
          packs = [
              p.name for p in packs_dir.iterdir()
              if (p / "pack_metadata.json").is_file()
          ]
          packs_str = " ".join(sorted(packs))
          print("Discovered packs:", packs_str or "(none)")

          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
              fh.write(f"packs={packs_str}\n")
          PY

      # 2) Detect packs with version changes vs HEAD^
      - name: Compute changed packs (version bump)
        id: changed
        env:
          ALL_PACKS: ${{ steps.discover.outputs.packs }}
        run: |
          python - << 'PY'
          import io, json, os, subprocess
          from pathlib import Path

          packs = os.environ["ALL_PACKS"].split()
          packs_dir = Path(os.environ["PACKS_DIR"])
          changed = []

          for pack in packs:
            meta_path = packs_dir / pack / "pack_metadata.json"
            if not meta_path.exists():
              continue

            new_meta = json.loads(meta_path.read_text())
            new_ver = new_meta.get("version") or new_meta.get("currentVersion") or ""

            try:
                blob = subprocess.check_output(
                    ["git", "show", f"HEAD^:{meta_path}"], text=True
                )
                old_meta = json.load(io.StringIO(blob))
                old_ver = old_meta.get("version") or old_meta.get("currentVersion") or ""
            except subprocess.CalledProcessError:
                old_ver = ""

            if new_ver != old_ver:
              print(f"{pack}: version changed {old_ver} -> {new_ver}")
              changed.append(pack)

          changed_str = " ".join(changed)
          print("Changed packs:", changed_str or "(none)")

          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
              fh.write(f"packs={changed_str}\n")
          PY

      # 3) Build zips + show what would happen (NO gh release, NO git commit)
      - name: Dry-run build & config update
        if: ${{ steps.changed.outputs.packs != '' }}
        env:
          CHANGED_PACKS: ${{ steps.changed.outputs.packs }}
          # IMPORTANT: run SDK in a content-repo context (prevents "external-" rewrite issues)
          DEMISTO_SDK_CONTENT_PATH: ${{ github.workspace }}
        run: |
          python - << 'PY'
          import json, os, subprocess, time
          from pathlib import Path

          packs_dir = Path(os.environ["PACKS_DIR"])
          changed = os.environ["CHANGED_PACKS"].split()
          repo = os.environ["GITHUB_REPOSITORY"]
          repo_root = Path.cwd()

          dist = Path("dist")
          dist.mkdir(exist_ok=True)

          def run_cmd(cmd, cwd=None, check=True):
              print("+", " ".join(cmd), f"(cwd={cwd or os.getcwd()})")
              return subprocess.run(cmd, check=check, cwd=cwd)

          def newest_matching_zip(pack: str) -> Path | None:
              # prepare-content output location can vary by SDK version/config; search dist recursively
              zips = list(dist.rglob("*.zip"))
              # Prefer zips that contain the pack name, otherwise take newest zip
              candidates = [z for z in zips if pack in z.name]
              pool = candidates or zips
              if not pool:
                  return None
              pool.sort(key=lambda p: p.stat().st_mtime)
              return pool[-1]

          for pack in changed:
            pack_path = packs_dir / pack
            meta_path = pack_path / "pack_metadata.json"
            config_path = pack_path / "xsoar_config.json"

            if not meta_path.exists():
              print(f"{pack}: no pack_metadata.json, skipping")
              continue

            meta = json.loads(meta_path.read_text())
            version = meta.get("version") or meta.get("currentVersion") or ""
            if not version:
              print(f"{pack}: no version/currentVersion, skipping")
              continue

            print(f"=== DRY RUN for pack={pack}, version={version} ===")

            # Snapshot current zips so we can detect what got created
            before = {p.resolve() for p in dist.rglob("*.zip")}

            # Build using prepare-content for marketplacev2 (XSIAM)
            run_cmd([
              "demisto-sdk", "prepare-content",
              "-i", str(pack_path),
              "-o", str(dist),
              "--marketplace", "marketplacev2",
            ], cwd=str(repo_root))

            after = {p.resolve() for p in dist.rglob("*.zip")}
            created = sorted(after - before)

            built_zip = None
            if created:
                # Prefer a zip with the pack name if present
                candidates = [z for z in created if pack in z.name]
                built_zip = (sorted(candidates) or created)[-1]
            else:
                # Fallback: pick newest matching zip in dist
                built_zip = newest_matching_zip(pack)

            if not built_zip or not built_zip.exists():
              print(f"{pack}: prepare-content produced no zip under dist/ (skipping)")
              continue

            print(f"Built demisto-sdk zip: {built_zip}")

            # Optional sanity check: ensure XSIAM-specific content exists in the zip
            try:
                listing = subprocess.check_output(["unzip", "-l", str(built_zip)], text=True)
                has_xsiam_bits = ("CorrelationRules" in listing) or ("XSIAMDashboards" in listing)
                print(f"Zip contains CorrelationRules/XSIAMDashboards: {has_xsiam_bits}")
                if not has_xsiam_bits:
                    print("WARNING: zip does not appear to include XSIAMDashboards/CorrelationRules")
            except Exception as e:
                print(f"WARNING: could not inspect zip contents ({e})")

            # Show what release tag/asset would be
            tag = f"{pack}-v{version}-staging"
            asset = f"{pack}-v{version}-staging.zip"
            url = f"https://github.com/{repo}/releases/download/{tag}/{asset}"
            print(f"Would create release tag: {tag}")
            print(f"Would upload asset:       {asset}")
            print(f"Resulting URL:            {url}")

            # Show how xsoar_config.json would be updated
            if not config_path.exists():
              print(f"{pack}: no xsoar_config.json; would skip URL update")
              continue

            cfg = json.loads(config_path.read_text())
            target_id = f"{pack}.zip"
            custom = cfg.get("custom_packs")
            found = False
            if isinstance(custom, list):
              for entry in custom:
                if isinstance(entry, dict) and entry.get("id") == target_id:
                  print(f"Would update custom_packs id={target_id} with url={url}")
                  found = True
                  break

            if not found:
              print(f"Would set top-level cfg['url'] = {url}")

          print("\nDRY RUN COMPLETE (no releases created, no commits pushed)")
          PY

      - name: No packs changed
        if: ${{ steps.changed.outputs.packs == '' }}
        run: |
          echo "No pack version changes detected. Skipping."
