name: SOC Packs Release + POV Staging Test (Single Pack)

on:
  push:
    branches:
      - staging
      - main

permissions:
  contents: write   # required for commits + releases

env:
  PACKS_DIR: Packs
  XSOAR_CONFIG_PATH: xsoar_config.json

jobs:

  ############################################
  # JOB 1: BUILD, RELEASE, UPDATE CONFIG, DEPLOY
  ############################################
  release-packs:
    # Avoid infinite loop after committing [skip ci]
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest

    # Use 'main' environment for main branch, otherwise 'staging'
    environment:
      name: ${{ github.ref == 'refs/heads/main' && 'main' || 'staging' }}

    outputs:
      environment: ${{ steps.envinfo.outputs.environment }}
      pack_name:   ${{ steps.changed.outputs.pack_name }}
      version:     ${{ steps.meta.outputs.version }}
      tag:         ${{ steps.meta.outputs.tag }}

    steps:
      # ------------------------------
      # 1. Checkout full history
      # ------------------------------
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed so we can read prior commit

      # ------------------------------
      # 2. Determine environment string (staging | main)
      # ------------------------------
      - name: Determine environment
        id: envinfo
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            echo "environment=main" >> "$GITHUB_OUTPUT"
          else
            echo "environment=staging" >> "$GITHUB_OUTPUT"
          fi

      # ------------------------------
      # 3. Find the FIRST changed pack (single-pack behavior)
      #    Looks for changed pack_metadata.json files
      # ------------------------------
      - name: Find changed pack
        id: changed
        run: |
          set -e

          # Handle first commit on a branch gracefully
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            BASE=HEAD~1
          else
            BASE=$(git hash-object -t tree /dev/null)
          fi

          CHANGED_FILES=$(git diff --name-only "$BASE" HEAD || true)

          PACKS=$(echo "$CHANGED_FILES" \
            | grep -E '^Packs/[^/]+/pack_metadata\.json$' \
            | awk -F'/' '{print $2}' \
            | sort -u || true)

          if [[ -z "$PACKS" ]]; then
            echo "No changed pack_metadata.json found. Nothing to do."
            echo "pack_name=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          FIRST_PACK=$(echo "$PACKS" | head -n1)

          echo "Found changed packs: $PACKS"
          echo "Using first pack only: $FIRST_PACK"

          echo "pack_name=$FIRST_PACK" >> "$GITHUB_OUTPUT"

      - name: Stop if no pack
        if: steps.changed.outputs.pack_name == ''
        run: |
          echo "No pack to process. Exiting."
          exit 0

      # ------------------------------
      # 4. Setup Python & demisto-sdk (UNPINNED)
      # ------------------------------
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install demisto-sdk
        run: |
          python -m pip install --upgrade pip
          pip install demisto-sdk

      # ------------------------------
      # 5. Read pack version from pack_metadata.json
      # ------------------------------
      - name: Read pack version
        id: meta
        run: |
          import json, os, pathlib
          pack_name = os.environ["PACK_NAME"]
          meta_path = pathlib.Path("Packs") / pack_name / "pack_metadata.json"
          meta = json.loads(meta_path.read_text())
          version = meta.get("currentVersion", meta.get("version", "0.0.0"))
          tag = f"{pack_name}_v{version}"
          print(f"Version: {version}")
          print(f"Tag: {tag}")
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"version={version}\n")
              f.write(f"tag={tag}\n")
        env:
          PACK_NAME: ${{ steps.changed.outputs.pack_name }}

      # ------------------------------
      # 6. Build ZIP for the pack (one pack, one zip)
      # ------------------------------
      - name: Build content artifact (zip)
        run: |
          set -e
          PACK_NAME="${{ steps.changed.outputs.pack_name }}"
          mkdir -p dist
          demisto-sdk zip-packs \
            -i "${PACKS_DIR}/${PACK_NAME}" \
            -o dist

          echo "Artifacts in dist/:"
          ls -la dist

      # ------------------------------
      # 7. Create GitHub Release (tag per pack/version)
      # ------------------------------
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name:     ${{ steps.meta.outputs.tag }}
          release_name: ${{ steps.meta.outputs.tag }}
          draft: false
          prerelease: false

      - name: Upload release asset
        id: upload_release_asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url:  ${{ steps.create_release.outputs.upload_url }}
          asset_path:  dist/${{ steps.changed.outputs.pack_name }}.zip
          asset_name:  ${{ steps.changed.outputs.pack_name }}.zip
          asset_content_type: application/zip

      # ------------------------------
      # 8. Update xsoar_config.json for THIS environment
      #    URL pattern:
      #    https://github.com/<org>/<repo>/releases/download/<tag>/<pack>.zip
      # ------------------------------
      - name: Update xsoar_config.json
        id: update_xsoar_config
        run: |
          import json, os, pathlib

          config_path = pathlib.Path(os.environ["XSOAR_CONFIG_PATH"])
          repo = os.environ["GITHUB_REPOSITORY"]
          pack_name = os.environ["PACK_NAME"]
          tag = os.environ["RELEASE_TAG"]
          environment = os.environ["ENVIRONMENT"]

          pack_url = f"https://github.com/{repo}/releases/download/{tag}/{pack_name}.zip"
          print(f"Pack URL for {environment}: {pack_url}")

          if config_path.exists():
              config = json.loads(config_path.read_text())
          else:
              config = {}

          if "environments" not in config:
              config["environments"] = {}

          if environment not in config["environments"]:
              config["environments"][environment] = {}

          # Single-pack entry with URL for this env
          config["environments"][environment][pack_name] = {
              "url": pack_url
          }

          config_path.write_text(json.dumps(config, indent=2, sort_keys=True))
        env:
          PACK_NAME:   ${{ steps.changed.outputs.pack_name }}
          RELEASE_TAG: ${{ steps.meta.outputs.tag }}
          ENVIRONMENT: ${{ steps.envinfo.outputs.environment }}

      # ------------------------------
      # 9. Commit updated xsoar_config.json back to the branch
      #    [skip ci] avoids infinite loop
      # ------------------------------
      - name: Commit & push xsoar_config.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add "${XSOAR_CONFIG_PATH}"

          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "Update xsoar_config for ${{ steps.envinfo.outputs.environment }} - ${{ steps.changed.outputs.pack_name }} [skip ci]"
          git push

      # ------------------------------
      # 10. Deploy to tenant (staging vs main)
      #     You already had a working pattern for this piece
      # ------------------------------
      - name: Deploy pack to tenant
        env:
          ENVIRONMENT:        ${{ steps.envinfo.outputs.environment }}
          PACK_NAME:          ${{ steps.changed.outputs.pack_name }}
          RELEASE_TAG:        ${{ steps.meta.outputs.tag }}
          GITHUB_REPOSITORY:  ${{ github.repository }}

          # EXPECTED SECRETS (same as before):
          #   STAGING_XSIAM_URL, STAGING_XSIAM_KEY
          #   MAIN_XSIAM_URL,    MAIN_XSIAM_KEY
          STAGING_XSIAM_URL:  ${{ secrets.STAGING_XSIAM_URL }}
          STAGING_XSIAM_KEY:  ${{ secrets.STAGING_XSIAM_KEY }}
          MAIN_XSIAM_URL:     ${{ secrets.MAIN_XSIAM_URL }}
          MAIN_XSIAM_KEY:     ${{ secrets.MAIN_XSIAM_KEY }}
        run: |
          set -e

          if [[ "$ENVIRONMENT" == "main" ]]; then
            XSIAM_URL="$MAIN_XSIAM_URL"
            XSIAM_KEY="$MAIN_XSIAM_KEY"
          else
            XSIAM_URL="$STAGING_XSIAM_URL"
            XSIAM_KEY="$STAGING_XSIAM_KEY"
          fi

          if [[ -z "$XSIAM_URL" || -z "$XSIAM_KEY" ]]; then
            echo "Tenant URL or key not set for environment: $ENVIRONMENT"
            exit 1
          fi

          PACK_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/${RELEASE_TAG}/${PACK_NAME}.zip"
          echo "Deploying pack from: $PACK_URL"
          echo "To tenant: $XSIAM_URL"

          # Adjust endpoint/body to exactly what you had working before
          curl -k -X POST \
            "${XSIAM_URL}/xsoar/public/v1/system/packs/install" \
            -H "Authorization: ${XSIAM_KEY}" \
            -H "Content-Type: application/json" \
            -d "{\"packs\":[{\"url\":\"${PACK_URL}\"}]}"
